---
title: Tenant Onboarding Guide (SDK + API)
description: Step-by-step setup for SDK integrations plus manual API flows.
---

<Callout type="info" title="Who this is for">
Most partners should use the SDK flow (Steps 1-2.1). The manual API steps are for advanced or non-SDK integrations.
</Callout>

## Prerequisites

You will receive from Aarthik:
- tenant_id
- application_id
- API key (server-side only)
- Base URL: https://credit.aarthiklabs.com

You must provide to Aarthik:
- Your parent origin (example: https://app.yourcompany.com)

## Step 1: Store API key securely

Store the API key in your backend environment. Do not expose it in the browser.

Example env:
- AARTHIK_API_KEY=your_api_key

## Step 1.1: Server environment (Self-hosted / Local only)

If you are calling the hosted API at https://credit.aarthiklabs.com, skip this section. If you are running this API locally or self-hosting it, set these env vars before Step 2.

Required (auth + bootstrap):
- DATABASE_URL=... (Postgres connection string; must contain tenants, applications, and API keys)
- API_KEY_PEPPER=... (HMAC pepper for API key hashing; random 32+ bytes; keep stable)
- JOURNEY_TOKEN_PEPPER=... (HMAC pepper for bootstrap/refresh token hashing; random 32+ bytes; keep stable)
- JOURNEY_ACCESS_JWT_SECRET_B64=... (base64-encoded HMAC secret for access JWTs; random 32+ bytes)
- JOURNEY_JWT_ISSUER=... (string, e.g., http://localhost:3000)
- JOURNEY_JWT_AUDIENCE=... (string, e.g., credit-api)

Optional (local admin + edge controls):
- SUPERUSER_API_KEY=... (required only for /api/superuser/* endpoints)
- API_CORS_* and API_RATE_LIMIT_* (defaults are fine in development)

Generate secrets (one-time):
```bash
openssl rand -base64 32
```

Example .env.local:
```bash
DATABASE_URL="postgres://user:password@localhost:5432/credit_api"
API_KEY_PEPPER="..."
JOURNEY_TOKEN_PEPPER="..."
JOURNEY_ACCESS_JWT_SECRET_B64="..."
JOURNEY_JWT_ISSUER="http://localhost:3000"
JOURNEY_JWT_AUDIENCE="credit-api"
SUPERUSER_API_KEY="..." # optional
```

Notes:
- Rotating API_KEY_PEPPER invalidates all existing API keys.
- Rotating JOURNEY_TOKEN_PEPPER invalidates existing bootstrap/refresh tokens.
- Rotating JOURNEY_ACCESS_JWT_SECRET_B64 or changing JOURNEY_JWT_ISSUER or JOURNEY_JWT_AUDIENCE invalidates existing access tokens.

## Step 2: Create a backend bootstrap endpoint

Create a backend endpoint that mints a bootstrap token on demand.

Request:
- `POST /api/tenants/{tenant_id}/applications/{application_id}/auth/bootstrap`
Headers:
- `x-api-key: API_KEY`
Body:
```json
{
  "allowed_parent_origin": "https://app.yourcompany.com"
}
```

Example curl:
```bash
curl -X POST \
  "https://credit.aarthiklabs.com/api/tenants/<tenant_id>/applications/<application_id>/auth/bootstrap" \
  -H "x-api-key: API_KEY" \
  -H "content-type: application/json" \
  -d '{"allowed_parent_origin":"https://app.yourcompany.com"}'
```

Response:
```json
{
  "bootstrap_token": "jbt_...",
  "expires_at": "2026-01-09T12:00:00.000Z"
}
```

## Step 2.1: Pass bootstrap token to the SDK (Recommended)

Once your backend mints a bootstrap token, your frontend only needs to pass it to the SDK component. The SDK handles exchange, refresh, provisioning, journey selection, and token rotation automatically.

SDK usage (example):
```tsx
<AarthikShell
  title="Aarthik Bandhu"
  triggerProperties={{ label: "Get A Loan" }}
  bootstrapToken={bootstrapToken}
/>
```

That is the entire client-side flow for SDK integrations:
1) Server: call the bootstrap API using your API key.
2) Client: pass the bootstrap token to the SDK component.

No additional steps are required on the integrator side.

## Step 3: Manual exchange (Non-SDK / Advanced)

If you are not using the SDK, call the exchange endpoint from your client.

Request:
POST /api/auth/exchange
Body:
```json
{
  "bootstrap_token": "jbt_...",
  "parent_origin": "https://app.yourcompany.com"
}
```

Example curl:
```bash
curl -X POST \
  "https://credit.aarthiklabs.com/api/auth/exchange" \
  -H "content-type: application/json" \
  -d '{"bootstrap_token":"jbt_...","parent_origin":"https://app.yourcompany.com"}'
```

Response:
```json
{
  "token_type": "Bearer",
  "access_token": "eyJ...",
  "scope": "provisioning",
  "expires_in": 900,
  "refresh_token": "jrt_...",
  "refresh_expires_at": "2026-01-09T13:00:00.000Z",
  "session_id": "uuid"
}
```

## Step 4: Provision a borrower (Non-SDK)

Provision the borrower using the access token from Step 3.

Request:
POST /api/sdk/provision
Headers:
- Authorization: Bearer ACCESS_TOKEN
Body:
```json
{
  "borrower_provider_id": "your-user-id",
  "contact_number": "+91XXXXXXXXXX"
}
```

Example curl:
```bash
curl -X POST \
  "https://credit.aarthiklabs.com/api/sdk/provision" \
  -H "authorization: Bearer ACCESS_TOKEN" \
  -H "content-type: application/json" \
  -d '{"borrower_provider_id":"user_123","contact_number":"+919999999999"}'
```

Response (existing borrower):
```json
{
  "borrower": { "id": "uuid", "provider_id": "user_123" },
  "journeys": [{ "id": "uuid", "created": "...", "status": "...", "type": "..." }],
  "attached": { "borrower_id": "uuid", "journey_id": null },
  "access_token": "eyJ...",
  "scope": "borrower",
  "expires_in": 900
}
```

## Step 5: Select or create a journey (Non-SDK)

If journeys exist, select one:

POST /api/sdk/journey/select
Headers:
- Authorization: Bearer ACCESS_TOKEN
Body:
```json
{ "journey_id": "uuid" }
```

If no journeys exist, create a new one:

POST /api/sdk/journey/create
Headers:
- Authorization: Bearer ACCESS_TOKEN
Body:
```json
{ "metadata": { "source": "sdk" } }
```

Both responses return a new access token with scope: journey.

## Step 6: Call journey APIs (Non-SDK)

Use the journey-scoped access token for borrower and journey routes:

- `/api/tenants/{tenant_id}/applications/{application_id}/borrowers/{borrower_id}/journeys/{journey_id}/...`

Example header:
- Authorization: Bearer JOURNEY_ACCESS_TOKEN

## Step 6.1: Iframe token handoff (postMessage v1)

If you are using the SDK, this is handled automatically. Only relevant when embedding the iframe manually.

The SDK and iframe must exchange tokens via postMessage. The iframe should only accept messages from the tenant origin, and the parent should only accept messages from the iframe origin.

Message envelope:
```json
{
  "type": "AARTHIK_SDK_READY",
  "version": "v1",
  "request_id": "uuid",
  "timestamp": "2026-01-09T12:00:00.000Z",
  "payload": {}
}
```

Handshake:
1. Iframe -> Parent: AARTHIK_SDK_READY
2. Parent -> Iframe: AARTHIK_SDK_AUTH (token payload)
3. Iframe -> Parent: AARTHIK_SDK_AUTH_ACK

Token update:
- Parent -> Iframe: AARTHIK_SDK_TOKEN_UPDATE
- Iframe -> Parent: AARTHIK_SDK_TOKEN_ACK

Logout:
- Parent -> Iframe: AARTHIK_SDK_LOGOUT

Token payload:
```json
{
  "token_type": "Bearer",
  "access_token": "eyJ...",
  "scope": "journey",
  "expires_in": 900,
  "session_id": "uuid",
  "borrower_id": "uuid",
  "journey_id": "uuid"
}
```

## Step 7: Refresh tokens (Non-SDK)

Before access token expiry, call refresh:

POST /api/auth/refresh
Body:
```json
{ "refresh_token": "jrt_..." }
```

Response returns a new access token and refresh token.

## Step 8: Logout (Non-SDK)

When the user finishes, revoke the session:

POST /api/auth/logout
Headers:
- Authorization: Bearer ACCESS_TOKEN
Body:
```json
{ "refresh_token": "jrt_..." }
```

Response:
```json
{ "success": true }
```

## CORS and rate limits

If you see CORS errors in the browser, ensure your origin is allowlisted by Aarthik. If you receive 429 responses, your integration is hitting API rate limits. Contact Aarthik support to adjust limits if needed.

## Troubleshooting

- 401 TOKEN_EXPIRED: refresh token and retry.
- 401 TOKEN_REUSED: re-bootstrap (session revoked).
- 403 Origin not allowed: update allowed parent origin and CORS allowlist.

## SDK integration checklist (Short)

- [ ] Receive tenant_id, application_id, and API key from Aarthik.
- [ ] Build a backend endpoint to mint bootstrap tokens (server-side only).
- [ ] Allowlist your parent origin for CORS and set allowed_parent_origin.
- [ ] Pass the bootstrap token to the SDK component (client-side).
- [ ] For non-SDK integrations only: implement exchange, provisioning, journey, token refresh, and logout flows.
